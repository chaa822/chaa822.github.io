{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n외부 api를 조회하여 데이터를 끌어오는 스케쥴러가 있었는데, 일부 데이터가 누락되는 이슈가 발생했다.\n\napi를 호출하는 코드는 대충 다음과 같다.\n\n```Java\n.\n.\n.\nResponseEntity<List<CustomDTO>> response = restTemplate.exchange(\n                                            url,\n                                            HttpMethod.GET,\n                                            new HttpEntity<>(\"\", httpHeaders),\n                                            new ParameterizedTypeReference<List<CustomDTO>>() {});\n.\n.\n.\nreturn response.getBody();                             \n```\n특정한 파라미터도 없었고, 브라우저에서 domain url로 붙어도 json data가 보이는 지극히 단순한 코드였는데 \n\nunquoted character ((ctrl-char code 13)) 오류가 간헐적으로 발생하고 있었다.\n   \njson valid 사이트에서 확인해보니, 다음과 같이 속성 값에 줄바꿈 때문에 다음 줄부터 오류가 발생했다.\n\n```text\n{ \"data\" : \"abc\ndef\"\n}\n```\n\n나는 다음과 같이 [ObjectMapper](https://www.baeldung.com/spring-boot-customize-jackson-objectmapper)를 사용해 해결했다.\n\n```Java\n.\n.\nObjectMapper objectMapperForAllowUnquotedControlChars = new ObjectMapper()\n            .configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);\n.\n.\n.\n.\nResponseEntity<String> response = restTemplate.exchange(\n                                            url,\n                                            HttpMethod.GET,\n                                            new HttpEntity<>(\"\", httpHeaders),\n                                            String.class);\n\nif( response.getBody() == null ){\n    return Collections.EMPTY_LIST();\n}\n\nreturn objectMapperForAllowUnquotedControlChars.readValue(response.getBody()\n                                            , new TypeReference<List<CustomDTO>>(){});\n```\n","excerpt":"외부 api를 조회하여 데이터를 끌어오는 스케쥴러가 있었는데, 일부 데이터가 누락되는 이슈가 발생했다. api를 호출하는 코드는 대충 다음과 같다. 특정한 파라미터도 없었고, 브라우저에서 domain url로 붙어도 json data가 보이는 지극히…","fields":{"slug":"/unquoted-character/"},"frontmatter":{"date":"May 20, 2022","title":"unquoted character ((ctrl-char code 13))","tags":["spring"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n문제 [링크](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n\n![](problem.png)\n\n**_Java 풀이_**\n```java\nimport java.util.*;\n\nclass Solution {\n    \n    public int maxProfit(int[] prices) {\n        int answer = 0;\n        int buy = Integer.MAX_VALUE;\n        \n        for(int i = 0; i < prices.length; i++){\n            if(prices[i] < buy){\n                buy = prices[i];\n            }else{                \n                answer = Math.max(answer, prices[i] - buy);\n            }            \n        }\n        return answer;\n    }\n}\n```\n\n**_Javascript풀이_**\n```javascript\n\nvar maxProfit = function(prices) {\n    let buy = 10000;\n    let answer = 0;\n    \n    for(let i = 0; i < prices.length; i++){\n        if(prices[i] < buy){\n            buy = prices[i];\n        }else{\n            answer = Math.max(answer, prices[i] - buy);\n        }\n    }\n    return answer;\n};\n```\n","excerpt":"문제 링크  Java 풀이 Javascript풀이","fields":{"slug":"/0121. Best Time to Buy and Sell Stock/"},"frontmatter":{"date":"Mar 06, 2022","title":"LeetCode - 121. Best Time to Buy and Sell Stock","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n문제 [링크](https://leetcode.com/problems/contains-duplicate/)\n\n![](problem.png)\n\n_**Java풀이**_\n```java\nimport java.util.*;\n\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Arrays.sort(nums);\n        for(int i = 1; i < nums.length; i++){\n            if( nums[i - 1] == nums[i] )\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n_**Javascript풀이**_\n```javascript\nvar containsDuplicate = function(nums) {\n\tnums.sort();\n\tfor(let i = 1; i < nums.length; i++){\n\t\tif( nums[i - 1] == nums[i] )\n\t\t\treturn true;\n\t}\n\treturn false;\n};\n```\n","excerpt":"문제 링크  Java풀이 Javascript풀이","fields":{"slug":"/0217. Contains Duplicate/"},"frontmatter":{"date":"Mar 05, 2022","title":"LeetCode - 217. Contains Duplicate","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n문제 [링크](https://leetcode.com/problems/maximum-subarray)\n\n![](problem.png)\n\n\n_**Java풀이**_\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        int max = nums[0];\n        int currentValue = nums[0];\n        for(int i = 1; i < nums.length; i++){\n            currentValue = Math.max(currentValue + nums[i], nums[i]);\n            max = Math.max(max, currentValue);\n        }\n        return max;\n    }\n}\n```\n\n_**Javascript풀이**_\n```javascript\nvar maxSubArray = function(nums) {\n    let max = nums[0];\n    let currentValue = nums[0];\n    for(let i = 1; i < nums.length; i++){\n        currentValue = Math.max(currentValue + nums[i], nums[i]);\n        max = Math.max(max, currentValue);\n    }\n    return max;\n};\n```\n","excerpt":"문제 링크  Java풀이 Javascript풀이","fields":{"slug":"/0053. Maximum Subarray/"},"frontmatter":{"date":"Mar 04, 2022","title":"LeetCode - 53. Maximum Subarray","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n문제 [링크](https://leetcode.com/problems/sum-of-two-integers/)\n\n![](problem.png)\n\n_**Java풀이**_\n```java\nclass Solution {\n    public int getSum(int a, int b) {\n        return a+b;\n    }\n}\n```\n\n_**Javascript풀이**_\n```javascript\nvar getSum = function(a, b) {\n    return a+b;\n};\n```\n","excerpt":"문제 링크  Java풀이 Javascript풀이","fields":{"slug":"/0371. Sum of Two Integers/"},"frontmatter":{"date":"Mar 02, 2022","title":"LeetCode - 371. Sum of Two Integers","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n문제 [링크](https://leetcode.com/problems/two-sum)\n\n![](problem.png)\n\n\n_**Java풀이**_\n```Java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {    \n        int[] answer = new int[2];\n        for(int i = 0; i < nums.length; i++){\n            for(int j = i+1; j < nums.length; j++){\n                if(nums[i] + nums[j] == target){\n                    answer[0] = i;\n                    answer[1] = j;\n                }\n            }\n        }\n        return answer;\n    }\n}\n```\n\n_**Javascript풀이**_\n```javascript\nvar twoSum = function(nums, target) {\n    let answer = [];\n    for(let i = 0; i < nums.length; i++){\n        for(let j = i+1; j < nums.length; j++){\n            if(nums[i] + nums[j] == target){\n                answer.push(i);\n                answer.push(j);\n                break;\n            }\n        }\n    }    \n    return answer;\n};\n```\n","excerpt":"문제 링크  Java풀이 Javascript풀이","fields":{"slug":"/0001. Two Sum/"},"frontmatter":{"date":"Mar 01, 2022","title":"LeetCode - 1. Two Sum","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"출처 :\n 인프런 강의 - 더 자바, Java 8 (백기선)\nhttps://www.inflearn.com/course/the-java-java8","fields":{"slug":"/thejava-java8_11/"},"frontmatter":{"date":"Feb 24, 2022","title":"더 자바, Java8 - Date와 DateTime","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"출처 :\n 인프런 강의 - 더 자바, Java 8 (백기선)\nhttps://www.inflearn.com/course/the-java-java8","fields":{"slug":"/thejava-java8_10/"},"frontmatter":{"date":"Feb 23, 2022","title":"더 자바, Java8 - Optional API","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"","excerpt":"","fields":{"slug":"/thejava-java8_9/"},"frontmatter":{"date":"Feb 22, 2022","title":"더 자바, Java8 - Optional 소개","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"출처 :\n 인프런 강의 - 더 자바, Java 8 (백기선)\nhttps://www.inflearn.com/course/the-java-java8","fields":{"slug":"/thejava-java8_8/"},"frontmatter":{"date":"Feb 20, 2022","title":"더 자바, Java8 - Stream API","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n###Stream 소개\n\n\n* stream : 연속된 데이터를 처리하는 연속된 오퍼레이터들의 모음\n* 특징\n   <br/>\n    1. 데이터를 담는 저장소가 아니다.\n    2. 스트림으로 처리하는 데이터는 오직 한번만 처리한다.\n    3. 근본적으로 Functional하다. (소스를 변경하지 않는다)\n    4. 무제한일 수도 있다.\n    5. 중개 오퍼레이터는 근본적으로 lazy하다.\n    6. 손쉽게 병렬 처리할 수 있다.\n<br/>\n<br/>\n* 중개형 오퍼레이터 : Stream을 리턴한다. -> map, filter ...\n* 종료형 오퍼레이터 : Stream을 리턴하지 않는다. -> count, collect, anyMath ...\n<br/>\n<br/>\n* 근본적으로 중개형 오퍼레이터들은 종료형 오퍼레이터가 오기 전까지 실행되지 않는다. (정의했을 뿐이다)\n* 실행되기 위해선 종료형 오퍼레이터가 마지막에 반드시 존재해야한다.\n\n<br/>\n종료형 오퍼레이터가 존재하지 않기 때문에, map안에서 sout을 찍어도 출력되지 않는다.\n\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        // 중개형 오퍼레이터 : 출력되지 않는다.\n        Stream<String> stringStream = name.stream().map(s -> {\n            System.out.println(s.toUpperCase());\n            return s.toUpperCase();\n        });\n    }\n}\n```\n종료형 오퍼레이터가 존재하기 때문에, 출력 된다.\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        List<String> collect = name.stream()\n                .map(s -> {\n                    System.out.println(s.toUpperCase());\n                    return s.toUpperCase();\n                })\n                .collect(Collectors.toList());\n    }\n}\n```\n\nparallelStream : 병렬 처리\n<br/>\nThread의 생성, 데이터 수집, Thread간의 컨텍스트 스위칭 등의 비용 때문에, 병렬 처리가 더 오래걸릴 수 있다.\n<br/>\n데이터가 정말 방대하게 큰 경우, 병렬처리를 사용한다.\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        List<String> collect1 = name.parallelStream()\n                .map(s -> {\n                    // stream(직렬)으로 했을 때와 parallelStream(병렬)으로 했을 때 이름이 다르게 나온다.\n                    System.out.println(s + \" \" + Thread.currentThread().getName());\n                    return s.toUpperCase();\n                })\n                .collect(Collectors.toList());\n    }\n}\n```\n\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"Stream 소개 stream : 연속된 데이터를 처리하는 연속된 오퍼레이터들의 모음 특징\n 데이터를 담는 저장소가 아니다. 스트림으로 처리하는 데이터는 오직 한번만 처리한다. 근본적으로 Functional하다. (소스를 변경하지 않는다) 무제한일 …","fields":{"slug":"/thejava-java8_7/"},"frontmatter":{"date":"Feb 19, 2022","title":"더 자바, Java8 - Stream 소개","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n###자바 8 API의 기본 메소드와 스태틱 메소드\n\nList 변수 생성\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n    }\n}\n```\n\nforeach : for문 생각하면 됨. 그런데 거기에 함수형 인터페이스를 얹은\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        // s에 괄호는 생략 가능\n        name.forEach((s) -> {\n            System.out.println(s);\n        });\n        \n        // 위의 코드를 아래와 같이 변경 가능 : 메소드 레퍼런스!\n        name.forEach(System.out::println);\n    }\n}\n```\n\niterator 활용\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        // 기존의 iterator 활용\n        Iterator<String> iterator = name.iterator();\n        while( iterator.hasNext() ){\n            System.out.println( iterator.next() );\n        }\n        \n        // 자바8에서의 iterator\n        // iterator와 비슷하지만, 쪼갤 수 있는 기능을 가지고 있는 iterator\n        Spliterator<String> spliterator = name.spliterator();\n        while( spliterator.tryAdvance(System.out::println) );\n        \n        // trySplit을 사용하면 반으로 쪼갠다.\n        Spliterator<String> newSpliterator = name.spliterator();\n        \n        // 기존의 newSpliterator는 반으로 나눠지고, 나머지 반은 newSpliterator2로 간다.\n        Spliterator<String> newSpliterator2 = newSpliterator.trySplit();\n        while( newSpliterator.tryAdvance(System.out::println) );\n        while( newSpliterator2.tryAdvance(System.out::println) );\n    }\n}\n```\n\nstream : 내부적으로 Spliterator를 사용하고 있음\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        long k = name.stream()\n                .map(String::toUpperCase)       // map : 요소 변환 -> spring => SPRING\n                .filter(s -> s.startsWith(\"S\")) // filter : 조건에 의한 필터 -> SPRING만 true\n                .count();                       // count : .size()\n        \n        // 1 출력\n        System.out.println(k);\n        \n        List<String> list = name.stream()\n                .map(String::toUpperCase)       // map : 요소 변환 -> spring => SPRING\n                .filter(s -> s.startsWith(\"S\")) // filter : 조건에 의한 필터 -> SPRING만 true\n                .collect(Collectors.toList());  // collect : 특정 대상으로 변환 -> List, Set ...\n        \n        // [SPRING] 출력\n        System.out.println(list.toString());\n    }\n}\n```\n\nremoveIf : 조건에 의한 삭제\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        name.removeIf(s -> s.startsWith(\"s\"));  // spring 요소 삭제\n        name.forEach(System.out::println);\n    }\n}\n```\n\nComparator : 함수형 인터페이스를 이용한 정렬\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        List<String> name = new ArrayList<>();\n        name.add(\"TheJava8\");\n        name.add(\"spring\");\n        name.add(\"toby\");\n        name.add(\"dev\");\n        \n        // 오름차순 정렬\n        name.sort(String::compareToIgnoreCase);\n        name.forEach(System.out::println);\n        \n        // 내림차순 정렬 : .reversed()\n        Comparator<String> compareToIgnoreCase = String::compareToIgnoreCase;\n        name.sort(compareToIgnoreCase.reversed());\n        name.forEach(System.out::println);\n        \n        // thenComparing -> 정렬 후 또 다른 조건으로 정렬하고 싶을 경우\n        name.sort(compareToIgnoreCase.reversed().thenComparing(compareToIgnoreCase.reversed()));\n        name.forEach(System.out::println);\n    }\n}\n```\n\nJava8 이전\n<br/>\n인터페이스 생성 -> a, b, c 함수 선언\n<br/>\n인터페이스를 구현하는 추상 클래스 (abstract class) 생성 -> a, b, c 함수 구현\n<br/>\n이유 : 추상 클래스를 상속 받아 구현하는 클래스에서 a, b, c 함수 중에 원하는 것만 골라서 구현할 수 있도록 편의성 제공\n<br/>\n(필요 없다면 구현 X)\n\nJava8 이후\n<br/>\n인터페이스에서 기본(default) 메서드를 사용해서 a, b, c 함수를 구현해 놓고\n<br/>\n추상 클래스 없이, 인터페이스를 직접 implements하는 방식\n<br/>\n<br/>\nex) WebMvcConfigurer.class, WebMvcConfigurerAdapter.class\n<br/>\n자바8 이전에는 WebMvcConfigurer에서 정의하고 WebMvcConfigurerAdapter에서 구현하였으나\n<br/>\nWebMvcConfigurer에서 default 메서드로 변경된 후 WebMvcConfigurerAdapter가 Deprecated되었다.\n\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"자바 8 API의 기본 메소드와 스태틱 메소드 List 변수 생성 foreach : for문 생각하면 됨. 그런데 거기에 함수형 인터페이스를 얹은 iterator 활용 stream : 내부적으로 Spliterator를 사용하고 있음 removeIf …","fields":{"slug":"/thejava-java8_6/"},"frontmatter":{"date":"Feb 18, 2022","title":"더 자바, Java8 - 자바 8 API의 기본 메소드와 스태틱 메소드","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n인터페이스 생성, 메서드 정의\n```Java\npublic interface Foo {\n    \n    void printName();\n}\n```\n\n인터페이스를 구현할 클래스 생성, 메서드 구현\n```Java\npublic class DefaultFoo implements Foo {\n\n    String name;\n\n    // 파라미터로 name을 받는다고 가정\n    public DefaultFoo(String name){\n        this.name = name;\n    }\n\n    @Override\n    public void printName(){\n        System.out.println(this.name);\n    }\n}\n```\n\n인스턴스 생성 및 메서드 호출\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        Foo foo = new DefaultFoo(\"TheJava8\");\n        \n        // TheJava8 출력\n        foo.printName();\n    }\n}\n\n```\n\n인터페이스에 새로운 메서드를 추가할 경우, 인터페이스를 구현한 모든 클래스에서 오류가 발생한다.\n<br/>이럴 경우, default 키워드를 이용해 기본 메서드를 오류 없이 추가할 수 있다.\n```Java\npublic interface Foo {\n    \n    void printName();\n    \n    default void printNameUpperCase(){\n        System.out.println(getName().toUpperCase());\n    }\n    \n    String getName();\n}\n```\n```Java\npublic class DefaultFoo implements Foo {\n    \n    @Override\n    public void printName(){\n        System.out.println(this.name);\n    }\n    \n    String name;\n    \n    // 파라미터로 name을 받는다고 가정\n    public DefaultFoo(String name){\n        this.name = name;\n    }\n    \n    // getName 메서드 구현\n    @Override\n    public String getName() {\n        return this.name;\n    }\n}\n```\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n    \n        Foo foo = new DefaultFoo(\"TheJava8\");\n        \n        // TheJava8 출력\n        foo.printName();\n        \n        // THEJAVA8 출력\n        foo.printNameUpperCase();\n    }\n}\n```\n\n기본 메서드는 구현하는 클래스에서 재정의할 수도 있다.\n```Java\npublic class DefaultFoo implements Foo {\n\n    @Override\n    public void printName(){\n        System.out.println(this.name);\n    }\n\n    String name;\n\n    // 파라미터로 name을 받는다고 가정\n    public DefaultFoo(String name){\n        this.name = name;\n    }\n    \n    @Override\n    public void printNameUpperCase() {\n        System.out.println(\"Overrided \" + this.name.toUpperCase());\n    }\n\n    // getName 메서드 구현\n    @Override\n    public String getName() {\n        return this.name;\n    }\n}\n```\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        Foo foo = new DefaultFoo(\"TheJava8\");\n        \n        // TheJava8 출력\n        foo.printName();\n        \n        // Overrided THEJAVA8 출력\n        foo.printNameUpperCase();\n    }\n}\n```\n\n하지만 인터페이스에서 제공하는 default 기능이 모든 구현체에서 정상적으로 동작하리라는 보장이 없다.\n<br/>(어떻게 구현했는지 모르기 때문에)\n<br/>\n<br/>\n따라서 오류 방지를 위해 최소한의 노력으로 아래와 같이 @ImplSpec을 이용해 문서화를 진행해야한다.\n\n```Java\npublic interface Foo {\n    \n    void printName();\n    \n    /**\n     * @ImplSpec 이 구현체는 getName()으로 가져온 문자를 대문자로 출력한다.\n     */\n    default void printNameUpperCase(){\n        System.out.println(getName().toUpperCase());\n    }\n    \n    String getName();\n}\n```\n\nObject가 제공하는 기능은 default 메서드로 제공할 수 없다.\n<br/> 하지만 추상 메서드로 선언하는 것은 가능하다.\n```Java\npublic interface Foo {\n    .\n    .\n    .\n    // 불가능 (error)\n    default String toString(){}\n    \n    // 가능\n    String toString();\n}\n```\n\nFoo 인터페이스를 상속받은 Bar 인터페이스에서 Foo가 제공하는 기본 메서드를 제공하고 싶지 않을 경우\n<br/>Bar 인터페이스에서 다시 추상 메서드로 선언한다.\n```Java\npublic interface Bar extends Foo {\n\n    // 이렇게 하면 Bar를 구현한 클래스에서 Override 해야한다.\n    void printNameUpperCase();\n}\n```\n```Java\npublic class DefaultBar implements Bar {\n\n    String name;\n\n    public DefaultBar(String name){\n        this.name = name;\n    }\n\n    @Override\n    public void printName() {\n        System.out.println(this.name);\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n    \n    @Override\n    public void printNameUpperCase() {\n        System.out.println(\"BAR\");\n    }\n}\n```\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        Bar bar = new DefaultBar(\"TheJava8\");\n        \n        // TheJava8 출력\n        bar.printName();\n        \n        // BAR 출력\n        bar.printNameUpperCase();\n    }\n}\n\n```\n\nFoo 인터페이스에도 default가 있고 Bar에도 default가 있는 경우, 구현하는 인터페이스에서 Foo/Bar 인터페이스를 둘 다 implements하게 되면 논리적으로 둘 중에 어떤 것을 사용해야할지 모르기 때문에 애매한 상황이 발생하여 컴파일 오류가 발생한다.\n</br>이렇게 충돌하는 경우에는 직접 Override를 해야 한다.\n```Java\npublic interface Bar {\n\n    void printName();\n\n    default void printNameUpperCase(){\n        System.out.println(getName().toUpperCase());\n    }\n\n    String getName();\n}\n```\n```Java\npublic interface Foo {\n\n    void printName();\n\n    default void printNameUpperCase(){\n        System.out.println(getName().toUpperCase());\n    }\n\n    String getName();\n}\n```\n```Java\npublic class DefaultBar implements Foo, Bar {\n\n    String name;\n\n    public DefaultBar(String name){\n        this.name = name;\n    }\n\n    @Override\n    public void printName() {\n        System.out.println(this.name);\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    @Override\n    public void printNameUpperCase() {\n        System.out.println(\"DEFAULT BAR\");\n    }\n}\n```\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        Bar bar = new DefaultBar(\"TheJava8\");\n        \n        // TheJava8 출력\n        bar.printName();\n        \n        // DEFAULT BAR 출력\n        bar.printNameUpperCase();\n    }\n}\n\n```\n\n유틸리티나 헬퍼 메서드를 제공하고 싶은 경우, static 키워드를 사용하여 메서드를 제공할 수 있다.\n```Java\npublic interface Foo {\n    .\n    .\n    static void printAnything(){\n        System.out.println(\"Foo\");\n    }\n}\n```\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n        \n        Foo.printAnything();\n    }\n}\n\n```\n\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"인터페이스 생성, 메서드 정의 인터페이스를 구현할 클래스 생성, 메서드 구현 인스턴스 생성 및 메서드 호출 인터페이스에 새로운 메서드를 추가할 경우, 인터페이스를 구현한 모든 클래스에서 오류가 발생한다.\n이럴 경우, default 키워드를 이용해 기…","fields":{"slug":"/thejava-java8_5/"},"frontmatter":{"date":"Feb 16, 2022","title":"더 자바, Java8 - 인터페이스 기본 메소드와 스태틱 메소드","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n람다를 사용해 문자를 인자로 받아 문자를 리턴하는 함수를 만들 경우, 다음과 같이 만든다.\n\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n\n        // Function : String을 받아서 String을 내보냄\n        Function<String, String> hi1 = (s) -> \"hi\" + s;\n        // hi TheJava8 출력\n        System.out.println( hi1.apply(\"TheJava8\") );\n        \n        // Input과 Ouput이 같은 경우, String을 하나로 줄일 수 있음\n        UnaryOperator<String> hi2 = (s) -> \"hi \" + s;\n        // hi TheJava8 출력\n        System.out.println( hi2.apply(\"TheJava8\") );\n    }\n}\n```\n\n위와 같이 인라인으로 람다 표현식을 작성할 수도 있지만, 다음과 같이 클래스를 이용해 생성할 수 있다.\n\nGreeting 클래스 생성\n```Java\npublic class Greeting {\n\n    private String name;\n\n    public Greeting() {\n\n    }\n\n    public Greeting(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String hello(String name) {\n        return \"hello \" + name;\n    }\n\n    public static String hi(String name) {\n        return \"hi \" + name;\n    }\n}\n```\n\n```Java\npublic class App {\n    public static void main(String[] args) {\n        .\n        .\n        .\n        // 클래스를 이용해 생성 -> 메서드가 static이어야 한다.\n        UnaryOperator<String> hi3 = Greeting::hi;\n        \n        // 스태틱 메서드가 아닌, 인스턴스 메서드를 이용해 생성할 경우 다음과 같이 작성\n        Greeting greeting = new Greeting();\n        UnaryOperator<String> hello = greeting::hello;\n        System.out.println( hello.apply(\"TheJava8\") );\n    }\n}\n```\nSupplier를 이용해 Greeting 클래스의 인스턴스를 가져올 수도 있다.\n<br/>\n다만 주의할 것은, newGreeting이 Greeting 클래스의 인스턴스가 아니므로 get 함수를 호출해 객체 생성을 해줘야 한다는 것이다.\n\n```Java\npublic class App {\n    public static void main(String[] args) {\n        .\n        .\n        .\n        // Supplier를 이용해 greeting 객체를 가져오는 함수 생성\n        Supplier<Greeting> newGreeting = Greeting::new;\n        // 주의 : newGreeting이 Greeting 클래스의 객체가 아니므로\n        // .get() 함수를 이용해 객체 생성을 해줘야 한다.\n        Greeting greeting2 = newGreeting.get();\n    }\n}\n```\n\nString name을 파라미터로 받는 생성자를 호출하고 싶다면 Function 인터페이스를 사용함이 옳다.\n<br/>\n다만, 아래의 Function과 위의 Supplier는 똑같이 'Greeting::'라는 키워드를 사용하지만\n<br/>호출되는 생성자는 서로 다르므로 혼동되지 말아야한다.\n\n```Java\npublic class App {\n\n    public static void main(String[] args) {\n        .\n        .\n        .\n        Function<String, Greeting> greeting3 = Greeting::new;\n        Greeting theJava8 = greeting3.apply(\"TheJava8\");\n        System.out.println( theJava8.getName() );\n    }\n}\n```\n\n일반적으로, 배열을 정렬할 때 다음과 같이 한다.\n```Java\npublic class App {\n    \n    public static void main(String[] args) {\n        .\n        .\n        .\n        String[] names = {\"TheJava8\", \"spring\", \"dev\"};\n        Arrays.sort(names, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return 0;\n            }\n        });\n    }\n}\n```\n\nComparator도 함수형 인터페이스로 변경되어 다음과 같이 작성이 가능하다.\n```Java\npublic class App {\n    public static void main(String[] args) {\n        .\n        .\n        .\n        Arrays.sort(names, (o1, o2) -> 0);\n        Arrays.sort(names, String::compareToIgnoreCase);\n        System.out.println(Arrays.toString(names));\n    }\n}\n```\n\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"람다를 사용해 문자를 인자로 받아 문자를 리턴하는 함수를 만들 경우, 다음과 같이 만든다. 위와 같이 인라인으로 람다 표현식을 작성할 수도 있지만, 다음과 같이 클래스를 이용해 생성할 수 있다. Greeting 클래스 생성 Supplier를 이용해 …","fields":{"slug":"/thejava-java8_4/"},"frontmatter":{"date":"Feb 14, 2022","title":"더 자바, Java8 - 메소드 레퍼런스","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n람다의 구조\n```Java\npubic class Foo {\n    \n    // main\n    public static void main(String[] args) {\n    \n        // () 부분 : 인자를 선언\n        // -> 이후 부분 : 함수의 바디\n        // 바디가 한 줄이면 중괄호를 생략 가능\n        UnaryOperator<Integer> plus10 = (i) -> i + 10;\n        UnaryOperator<Integer> plus20 = (i) -> {\n            i = i + 10;\n            i = i + 10;\n            return i;\n        };\n        // 11 출력\n        System.out.println(plus10.apply( 1 ));\n        // 21 출력\n        System.out.println(plus20.apply( 1 ));\n        \n        // Supplier의 경우, 인자를 받지 않기 때문에 ()부분이 비어 있음\n        // 마찬가지로 한줄일 경우 생략 가능\n        Supplier<Integer> get10 = () -> 10;\n        // 10 출력\n        System.out.println( get10.get() );\n        \n        // BiFuction의 경우, 인자 두개를 받아서 하나의 결과 값을 리턴하는 함수형 인터페이스\n        BiFunction<Integer, Integer, Integer> sum1 = (a, b) -> a + b;\n        // 인자와 리턴 값이 변수형이 같다면 BinaryOperator<T>로 줄일 수 있다.\n        BinaryOperator<Integer> sum2 = (a, b) -> a + b;\n        // 20 출력\n        System.out.println( sum1.apply(10, 10) );\n        // 20 출력\n        System.out.println( sum2.apply(10, 10) );\n    }\n}\n```\n\n람다의 범위\n<br/>\n<br/>\n로컬 클래스나 익명 클래스의 경우, 함수 바깥에 있는 변수를 참조할 수 있다.\n<br/>\n이 때, 참조하는 baseNumber 변수가 사실상 변경되지 않는 경우 final 키워드를 생략할 수 있다.\n<br/>\n\n\n```Java\npublic class Foo {\n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        foo.run();\n    }\n    \n    priavte void run() {\n        // effective final\n        // final 키워드를 생략할 수 있는 경우 : 이 변수가 사실상 final인 경우 (변경되지 않음)\n        final int baseNumber = 10;\n        \n        // 로컬 클래스\n        class localClass {\n            void printNumber(){\n                System.out.println(baseNumber);\n            }\n        }\n        \n        // 익명 클래스\n        Consumer<Integer> integerConsumer = new Consumer<Integer>() {\n            @Override\n            public void accept(Integer integer) {\n                System.out.println(baseNumber);\n            }\n        };\n    }\n}\n```\n\n또한 로컬 클래스나 익명 클래스 내부에 baseNumber 변수를 선언해도 함수의 범위가 다르기 때문에\n<br/>\n오류가 발생하지 않으며, 내부의 baseNumber 변수가 우선 시 된다.\n<br/>\n이를 쉐도잉 (로컬 클래스 or 익명 클래스 함수 안의 변수가 외부의 변수보다 우선시 됨)이라고 한다.\n\n```Java\npublic class Foo {\n\n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        foo.run();\n    }\n    \n    private void run(){\n        // effective final\n        // final 키워드를 생략할 수 있는 경우 : 이 변수가 사실상 final인 경우 (변경되지 않음)\n        final int baseNumber = 10;\n        \n        // 로컬 클래스\n        class localClass {\n            void printNumber(){\n                // 함수의 범위가 다르기 때문에 내부의 baseNumber가 출력되며\n                // 오류가 발생하지 않는다.\n                int baseNumber = 12;\n                // 12 출력\n                System.out.println(baseNumber);\n            }\n        }\n\n        // 익명 클래스\n        Consumer<Integer> integerConsumer = new Consumer<Integer>() {\n            @Override\n            public void accept(Integer integer) {\n                // 함수의 범위가 다르기 때문에 내부의 baseNumber가 출력되며\n                // 오류가 발생하지 않는다.\n                int baseNumber = 13;\n                // 13 출력\n                System.out.println(baseNumber);\n            }\n        };\n    }\n}\n```\n\n하지만 람다의 함수 범위는 상위 run 함수와 같기 때문에 (쉐도잉이 되지 않는다)\n<br/>\nbaseNumber 변수를 선언할 경우 컴파일 오류가 발생한다.\n<br/>\n\n\n```Java\npublic class Foo {\n    \n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        foo.run();\n    }\n    \n    private void run() {\n        \n        final int baseNumber = 10;\n        .\n        .\n        .\n        // 람다\n        IntConsumer printInt = (i) -> {\n            // ERROR : Variable baseNumber is already defined in the scope.\n//            int baseNumber = 11;\n            System.out.println(i + baseNumber);\n        };\n    }\n}\n```\n\n또한 람다 밑에서 baseNumber의 값을 변경하려고 할 경우,\n<br/>\n이미 baseNumber는 effective final이기 때문에 컴파일 오류가 발생한다.\n```Java\npublic class Foo {\n    \n    public static void main(String[] args) {\n        Foo foo = new Foo();\n        foo.run();\n    }\n    \n    private void run() {\n        \n        final int baseNumber = 10;\n        .\n        .\n        .\n        // 람다\n        IntConsumer printInt = (i) -> {\n            // ERROR\n            // Variable used in lambda expression should be final or effectively final\n            System.out.println(i + baseNumber);\n        };\n        \n        baseNumber++;\n    }\n}\n```\n\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"람다의 구조 람다의 범위\n\n\n로컬 클래스나 익명 클래스의 경우, 함수 바깥에 있는 변수를 참조할 수 있다.\n\n이 때, 참조하는 baseNumber 변수가 사실상 변경되지 않는 경우 final 키워드를 생략할 수 있다.\n 또한 로컬 클래스나 익명 클래…","fields":{"slug":"/thejava-java8_3/"},"frontmatter":{"date":"Feb 13, 2022","title":"더 자바, Java8 - 람다 표현식","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n먼저, 클래스에서 Function 인터페이스를 구현하여 사용할 수 있다.\n```Java\npublic class Plus10 implements Function<Integer, Integer> {\n\n    // Function 인터페이스를 구현한다.\n    \n    @Override\n    public Integer apply(Integer integer){\n        return integer + 10;\n    }\n}\n```\n```Java\npublic class Foo {\n\n    public static void main(String[] args) {\n\n        // Plus10 클래스의 객체를 생성하여 호출한다.\n        Plus10 plus10 = new Plus10();\n        \n        // 11출력\n        System.out.println( plus10.apply(1) );\n    }\n}\n```\n\n아니면 자바에서 기본적으로 제공하는 함수형 인터페이스를 사용할 수 있다.\n \n```Java\npublic class Foo {\n\n    public static void main(String[] args) {\n\n        // Function : T 타입을 받아서 R 타입을 리턴하는 함수 인터페이스\n        // 별도의 클래스 없이 바로 구현할 수 있다.\n        \n        // 파라미터에 20을 더하는 함수\n        Function<Integer, Integer> plus20 = (i) -> i + 20;\n        // 21 출력\n        System.out.println( plus20.apply(1) );\n\n        // 파라미터에 2를 곱하는 함수\n        Function<Integer, Integer> multiply2 = (i) -> i * 2;\n        // 2 출력\n        System.out.println( multiply2.apply(1) );\n\n        // 조합도 가능\n        // compose : 10을 더하기 전에, 2를 곱하겠다.\n        Function<Integer, Integer> multiply2AndPlus10 = plus10.compose(multiply2);\n        // 14 출력\n        System.out.println( multiply2AndPlus10.apply(2) );\n\n        // andThen : 10을 더한 뒤, 2를 곱하겠다.\n        Function<Integer, Integer> plus10AndMultiply2 = plus10.andThen(multiply2);\n        // 24 출력\n        System.out.println( plus10AndMultiply2.apply(2) );\n\n        // Consumer : T 타입을 받아서 아무값도 리턴하지 않는 함수 인터페이스\n        // 파라미터를 받아서 출력하겠다.\n        Consumer<Integer> printT = (i) -> System.out.println(i);\n        // 10 출력\n        printT.accept(10);\n\n        // Supplier : T 타입의 값을 제공하는 함수 인터페이스 (입력 값을 받지 않는다.)\n        // 무조건 10을 리턴하는 함수\n        Supplier<Integer> get10 = () -> 10;\n        // 10 출력\n        System.out.println( get10.get() );\n\n        // Predicate : T 타입을 받아서 boolean을 리턴하는 함수 인터페이스\n        // a로 시작하는지 true/false를 리턴하는 함수\n        Predicate<String> startsWith = (s) -> s.startsWith(\"a\");\n        // true 출력\n        System.out.println( startsWith.test(\"abcd\") );\n\n        // 짝수인지 검사하는 함수\n        Predicate<Integer> isEven = (num) -> num % 2 == 0;\n        // true 출력\n        System.out.println( isEven.test(2) );\n\n        // Predicate 조합도 가능\n        // negate : true/false에 대해서 not을 붙인다.\n        Predicate<Integer> isOdd = isEven.negate();\n        // false 출력\n        System.out.println( isOdd.test(2) );\n\n        // and : 동시 조건\n        // false 출력\n        System.out.println( isEven.and(isOdd).test(1) );\n\n        // or : 따로 조건\n        // true 출력\n        System.out.println( isEven.or(isOdd).test(1));\n\n        // UnaryOperator :\n        // Function<T, R>의 특수한 형태로, 입력값 하나를 받아서 동일한 타입을 리턴하는 함수 인터페이스\n        UnaryOperator<Integer> integerUnaryOperator = (i) -> i + 10;\n        // 11 출력\n        System.out.println( integerUnaryOperator.apply(1) );\n    }\n}\n\n```\n\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"먼저, 클래스에서 Function 인터페이스를 구현하여 사용할 수 있다. 아니면 자바에서 기본적으로 제공하는 함수형 인터페이스를 사용할 수 있다. 출처 :\n 인프런 강의 - 더 자바, Java 8 (백기선)\nhttps://www.inflearn.co…","fields":{"slug":"/thejava-java8_2/"},"frontmatter":{"date":"Feb 12, 2022","title":"더 자바, Java8 - 자바에서 제공하는 함수형 인터페이스","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n인터페이스 생성\n다음과 같이 추상 메서드가 딱 하나만 존재하면, 함수형 인터페이스라고 정의한다.\n```Java\npublic interface RunSomething {\n    \n    /* public, abstract 키워드는 생략 가능. */\n    void doIt();\n}\n```\n\n다음과 같이 추상 메서드가 2개 이상일 경우, 함수형 인터페이스가 아니다.\n```Java\npublic interface RunSomething {\n    \n    /* public, abstract 키워드는 생략 가능. */\n    void doIt();\n    \n    void doItAgain();\n}\n```\n\nstatic, default 메서드를 정의할 수도 있으며 다른 형태의 메서드를 정의하더라도\n<br/>추상 메서드는 하나이기 때문에 함수형 인터페이스라고 할 수 있다.\n```Java\npublic interface RunSomething {\n    \n    /* public, abstract 키워드는 생략 가능. */\n    void doIt();\n    \n    static void printName(){\n        System.out.println(\"TheJava8\");\n    }\n    \n    default void printAge(){\n        System.out.println(\"20\");\n    }\n}\n```\n\n만약 함수형 인터페이스를 명시적으로 정의하고 싶다면\n<br/>자바가 기본적으로 제공하는 어노테이션인 @FunctionalInterface를 사용하여 좀 더 견고하게 사용할 수 있다.\n(추상 메서드가 2개 이상일 경우 오류를 노출함)\n\n```Java\n@FunctionalInterface\npublic interface RunSomething {\n    \n    /* public, abstract 키워드는 생략 가능. */\n    void doIt();\n    \n    static void printName(){\n        System.out.println(\"TheJava8\");\n    }\n    \n    default void printAge(){\n        System.out.println(\"20\");\n    }\n}\n```\n\nRunSomething 인터페이스를 구현해보자.\n<br/>아래와 같은 형태를 익명 내부 클래스(anonymous inner class)라고 한다.\n```Java\npublic class Foo {\n    public static void main(String[] args) {\n        \n        // 익명 내부 클래스 (anonymous inner class)\n        RunSomething runSomething = new RunSomething() {\n            @Override\n            public void doIt() {\n                System.out.println(\"hello\");\n                System.out.println(\"Rambda\");\n            }\n        };\n        \n        // hello\n        // Rambda 출력\n        runSomething.doIt();\n    }\n}\n```\n\n위와 같은 익명 내부 클래스를 람다 표현식의 형태로 표현하면 다음과 같다.\n단, 이러한 코드는 내부코드가 한줄일 경우에만 가능하고, 2줄 이상일 경우 중괄호로 묶어줘야 한다.\n```Java\npublic class Foo {\n    public static void main(String[] args) {\n        \n        // rambda 표현식으로 변경 가능. 단, doIt안의 코드가 한 줄 일 경우에만\n        RunSomething runSomething = () -> System.out.println(\"hello\");\n        runSomething.doIt();\n        \n        // 2줄 이상일 경우 중괄호로 묶어야 한다.\n        RunSomething runSomething2 = () -> {\n            System.out.println(\"hello\");\n            System.out.println(\"world\");\n        };\n        runSomething2.doIt();\n    }\n}\n```\n\n위와 같이 람다 표현식을 사용하면 마치 다른 언어와 같이 함수를 정의한 것으로 보일 수 있지만\n<br/>실제로는 함수형 인터페이스를 인라인으로 구현한 특수한 형태의 오브젝트이다.\n\n또한 함수를 파라미터로 받는다거나, 함수가 함수를 리턴하는 것이 가능하다.\n<br/>(함수를 First class object로 사용할 수 있다.)\n\n<br/>위에서 선언한 추상 메서드인 doIt의 리턴 값을 int로 변경해보자.\n```Java\n@FunctionalInterface\npublic interface RunSomething {\n\n    int doIt(int number);\n}\n```\n\n그리고 아래와 같이 파라미터에 10을 더해서 값을 리턴하는 함수를 정의할 경우,\n<br/>입력한 값에 따라 결과 값을 보장할 수 있다.\n\n```Java\npublic class Foo {\n\n    public static void main(String[] args) {\n\n        // 입력 받은 값이 동일한 경우 결과가 같아야한다.\n        RunSomething runSomething = (number) -> {\n            return number + 10;\n        };\n\n        // 11 출력\n        System.out.println( runSomething.doIt(1) );\n        // 12 출력\n        System.out.println( runSomething.doIt(2) );\n    }\n}\n\n```\n\n그런데 아래와 같이 리턴 값이 보장해주지 못하는 상황이 발생할 가능성이 있다면\n<br/>함수형 프로그래밍이(퓨어 함수)라고 판단할 수 없다.\n<br/>\n<br/>\n예) 함수 바깥의 변수를 사용하는 경우 \n```Java\npublic class Foo {\n\n    public static void main(String[] args) {\n        \n        // 함수의 바깥의 변수\n        // int baseNumber = 10;\n        \n        RunSomething runSomething = new RunSomething() {\n            \n            // 함수 바깥의 변수\n            int baseNumber = 10;\n            \n            @Override\n            public void doIt(number) {\n                return number + baseNumber;\n            }\n        };\n        runSomething.doIt();\n    }\n}\n```\n\n예) 외부의 값을 변경하려는 경우\n```Java\npublic class Foo {\n    public static void main(String[] args) {\n        int baseNumber = 10;\n        \n        RunSomething runSomething = new RunSomething() {\n            @Override\n            public void doIt() {\n                // 컴파일 오류\n                baseNumber++;\n                return number + baseNumber;\n            }\n        };\n        runSomething.doIt();\n    }\n}\n```\n\n출처 :\n<br/> 인프런 강의 - 더 자바, Java 8 (백기선)\n<br/>https://www.inflearn.com/course/the-java-java8\n","excerpt":"인터페이스 생성\n다음과 같이 추상 메서드가 딱 하나만 존재하면, 함수형 인터페이스라고 정의한다. 다음과 같이 추상 메서드가 2개 이상일 경우, 함수형 인터페이스가 아니다. static, default 메서드를 정의할 수도 있으며 다른 형태의 메서드를…","fields":{"slug":"/thejava-java8_1/"},"frontmatter":{"date":"Feb 10, 2022","title":"더 자바, Java8 - 함수형 인터페이스와 람다 표현식","tags":["TheJava-Java8"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n알고리즘을 공부하거나 코딩테스트를 준비하다보면\n문제에서 요구하지 않더라도 풀이과정에서 소수판별 함수가 필요한 경우가 많다.\n깊게 고민해보지 않았더니 계속 찾아보게 되어서 자세한 내용을 정리한다.\n\n#\n_**소수란 수학에서 1과 그수 자신 이외의 자연수로는 나눌 수 없는, 1보다 큰 자연수이다.**_\n#\n위의 명제를 따르자면 특정 수 N의 약수가 1과 N 2개로 떨어지면 소수라고 판별할 수 있다.\n<br/>이걸 코드로 표현하면 다음과 같다.\n\n```java\n// 소수판별 함수\n// 1~N까지 반복하여 나누면서 나누어떨어지면 count를 증가시킨다.\npublic boolean isPrime(int N){\n\t// 위의 명제에서 \"1보다 큰 자연수\"이므로 1은 소수가 아니다.\n\tif( N == 1 ) return false;\n\n\tint count = 0;\n\t\n\t// i := 1 ~ N (i가 N의 약수인지 확인)\n\tfor(int i = 1; i <= N; i++){\n\t\tif( N % i == 0 ){\n\t\t\tcount += 1;\n\t\t}\n\t}\n\treturn count == 2;\n}\n```\n\n위의 함수를 실행했을 때 숫자 N이 10억을 넘어가면?\n<br/>모든 숫자를 반드시 순회하므로, 속도가 크게 떨어질 수 밖에 없다.\n\n이 함수를 어떻게 개선할 수 있을까? \n<br/>먼저 짝수를 생각해 볼 수 있다.\n\n가장 작은 짝수 2는 약수가 1과 2로 두개이므로 소수라고 판단한다.\n<br/>그러나 2보다 큰 짝수, 즉 4이상의 짝수는 반드시 약수를 2로 가진다.\n>4 → 1, 2, 4의 약수를 가진다.\n<br/>6 → 1, 2, 3, 6의 약수를 가진다.\n<br/>8 → 1, 2, 4, 8의 약수를 가진다.\n\n따라서 2를 제외한 모든 짝수는 약수의 개수가 3이상이므로 소수가 아니다.\n<br/>그렇다면 개선된 코드는 다음과 같다.\n\n```java\npublic boolean isPrime(int N){\n\t// 1은 소수가 아니다.\n\tif( N == 1 ) return false;\n   \t// 2는 소수다.\n\tif( N == 2 ) return true;\n\t// 2보다 큰 짝수는 소수가 아니다.\n\tif( N % 2 == 0 ) return false;\n\n\tint count = 0;\n\t// i := 1 ~ N (i가 N의 약수인지 확인)\n\tfor(int i = 1; i <= N; i++){\n\t\tif( N % 2 == 0 )\n\t\t\tcount += 1;\n\t}\n\treturn count == 2;\n}\n```\n\n여기서 시간을 좀 더 줄이기 위해 생각할 수 있는 부분은 약수의 쌍에 대한 부분이다\n<br/>예를 들어 숫자 100을 생각해보자. (100은 짝수지만 예를 들기 위해)\n\n100의 약수는 1, 2, 4, 5, 10, 20, 25, 50, 100이다.\n\n여기서 1과 100은 곱하면 N이 되므로 한쌍을 이룬다.\n<br/>마찬가지로 2와 50은 한쌍이다.\n<br/>4와 25 또한 한쌍이다.\n<br/>5와 20은 한쌍이다.\n<br/>10은 그 자신과 한쌍이다. (제곱)\n\n그렇다면 10을 기준으로 두고 1,2,4,5를 왼쪽으로, 20,25,50,100을 오른쪽으로 놓고 보면\n\n숫자 N (100) = a (1,2,4,5) * b (20,25,50,100)이라고 볼 수 있다. (단, a <= b)\n\n여기서 약수 a가 있다면 쌍을 이루는 b도 반드시 존재한다는 전제가 깔린다.\n\n그렇다면 우리는 a에서 1을 제외하고\n<br/>2부터 10까지 반복하면서 a(왼쪽)가 1개라도 존재하는지 확인하면 되지 않을까?\n\n숫자 10은 100(N)의 제곱근이면서 약수임을 생각한다면 코드는 다음과 같이 바뀔 수 있다.\n\n```java\npublic boolean isPrime(int N){\n\t// 1은 소수가 아니다.\n\tif( N == 1 ) return false;\n   \t// 2는 소수다.\n\tif( N == 2 ) return true;\n\t// 2보다 큰 짝수는 소수가 아니다.\n\tif( N % 2 == 0 ) return false;\n    \n   \tint count = 0;\n   \t// i := 2 ~ N의 제곱근 (i가 N의 약수인지 확인)\n\tfor(int i = 2; i <= Math.sqrt(N); i++){\n\t\tif( N % i == 0 ){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count == 0;\n}\n```\n\n위의 코드에서 이미 우리는 4이상의 짝수가 소수가 아니라고 위에서 판단하였으므로 홀수만 생각하면 된다.\n<br/>그렇다면 코드는 다시 한번 아래와 같이 바뀐다.\n\n```java\npublic boolean isPrime(int N){\n\t// 1은 소수가 아니다.\n\tif( N == 1 ) return false;\n\t// 2는 소수다.\n\telse if( N == 2 ) return true;\n\t// 2보다 큰 짝수는 소수가 아니다.\n\telse if( N % 2 == 0 ) return false;\n\t\t\n\tint count = 0;\n\t// i := 3 ~ N의 제곱근 (i가 N의 약수인지 확인)\n\t// 1을 제외한 홀수여야 하므로, 3으로 시작해서 2씩 증가한다. (3,5,7,9...)\n\tfor(int i = 3; i <= Math.sqrt(N); i += 2){\n\t\tif( N % i == 0 ){\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count == 0;\n}\n```\n\n이때, N이 i로 나누어 떨어지면 → i가 N의 약수이므로,\n<br/>count를 증가시키지 않고 반복문을 증가하며 false를 리턴한다.\n```Java\npublic boolean isPrime(int N){\n\t// 1은 소수가 아니다.\n\tif( N == 1 ) return false;\n\t// 2는 소수다.\n\telse if( N == 2 ) return true;\n\t// 2보다 큰 짝수는 소수가 아니다.\n\telse if( N % 2 == 0 ) return false;\n\t\n\t// i := 3 ~ N의 제곱근 (i가 N의 약수인지 확인)\n\t// 1을 제외한 홀수여야 하므로, 3으로 시작해서 2씩 증가한다. (3,5,7,9...)\n\tfor(int i = 3; i <= Math.sqrt(N); i += 2){\n\t    // i가 N의 약수이면 count를 증가하지 않고 fasle 리턴\n\t\tif( N % i == 0 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\t// 위의 반복문에서 종료되지 않았다면 약수가 없는 소수이므로 true 리턴\n\treturn true;\n}\n```\n","excerpt":"알고리즘을 공부하거나 코딩테스트를 준비하다보면\n문제에서 요구하지 않더라도 풀이과정에서 소수판별 함수가 필요한 경우가 많다.\n깊게 고민해보지 않았더니 계속 찾아보게 되어서 자세한 내용을 정리한다.  소수란 수학에서 1과 그수 자신 이외의 자연수로는 나…","fields":{"slug":"/about_prime/"},"frontmatter":{"date":"Feb 08, 2022","title":"소수 판별에 대하여 (Java)","tags":["Algorithm"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n어제 분명히 커밋 & 푸시를 했는데.. 오늘 보니까 잔디에 적용이 안 돼 있다. ~~(개빡치네)~~\n\n파일을 지우고 다시 커밋했는데도 적용이 안됨\n\n(참고 : fork한 repository는 안되는게 맞다)   \n.   \n.   \n\n찾아보니 유저이름과 이메일 설정이 뭔가 꼬인 것 같다.\n\n### 계정 초기화\n```bash\ngit config --global --unset user.name\ngit config --global --unset user.email\n```\n\n### 계정 재설정\n```bash\ngit config user.name \"userName\"\ngit config user.email email@domain.com\n```\n\n\n출처 : https://rizni.tistory.com/207\n","excerpt":"어제 분명히 커밋 & 푸시를 했는데.. 오늘 보니까 잔디에 적용이 안 돼 있다. (개빡치네) 파일을 지우고 다시 커밋했는데도 적용이 안됨 (참고 : fork한 repository는 안되는게 맞다) . .    찾아보니 유저이름과 이메일 설정이 뭔가 …","fields":{"slug":"/github-jandi/"},"frontmatter":{"date":"Feb 06, 2022","title":"Github 잔디가 적용되지 않을 때 (git name 초기화)","tags":["github"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n아래 코드를 개발자 도구에서 실행하거나, 즐겨찾기 url에 붙여넣기한 후 실행한다. \n\n```javascript\nfunction naver(q){\n    void(z=q.body.appendChild(q.createElement('script')));\n    void(z.language='javascript');\n    void(z.type='text/javascript');\n    void(z.src='http://userscripts.org/scripts/source/61326.user.js');\n}\n\nfunction selfw(w) {\n    try {\n        naver(w.document);\n    } catch(e){}\n\n    for (var i = 0; i < w.frames.length; i++) {\n        try {\n            selfw(w.frames[i]);\n        } catch(e){}\n    }\n}\nselfw(self);\n\n(function() {\n    var e, i, all;\n\n    document.onselectstart = null;\n    document.oncontextmenu = null;\n\n    all = document.getElementsByTagName(\"*\");\n\n    for(i = 0; i < all.length; i += 1) {\n        e = all[i];\n        e.onselectstart = null;\n        e.oncontextmenu = null;\n    }\n})();\n```\n","excerpt":"아래 코드를 개발자 도구에서 실행하거나, 즐겨찾기 url에 붙여넣기한 후 실행한다.","fields":{"slug":"/disable-anti-drag/"},"frontmatter":{"date":"Feb 01, 2022","title":"드래그 방지 해제","tags":["disable-drag"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n원래 나는 맥북에어를 약 1년간 사용해왔는데, 인텔리제이를 돌렸더니 멈췄다. (젠장 -_-)\n\n그래서 몇달을 고민하다 맥북프로로 넘어왔는데, node를 설치한 후에 블로그 포스팅을 하려고 npm install 명령어를 때렸더니 오류가 났다.\n\n찾아봤더니 설치된 버전이 16이어서, 버전이 안맞아서 그렇단다.\n\n그래서 기존에 설치했던 Node를 다 지우고, brew install node@14로 설치를 하려고 했으나 또 오류가 났다. \n\n#### nvm 다시 설치\n```bash\nbrew install nvm\n```\n\n설치가 되었다면 아래 그림처럼 결과가 나오는데, 자세히 보면 NVM이 동작하기 위한 설명이 나온다.\n![](screenshot1.png)\n\n#### nvm 폴더 생성\n```bash\nmkdir ~/.nvm\n```\n\n#### .zshrc 수정\n```bash\nvi ~/.zshrc\n```\n\n#### INSERT 모드로 아까 터미널에 있던 아래 내용을 최하단에 붙여넣고 저장한다.\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"/opt/homebrew/opt/nvm/nvm.sh\" ] && \\. \"/opt/homebrew/opt/nvm/nvm.sh\"  # This loads nvm\n[ -s \"/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm\" ] && \\. \"/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm\"  # This loads nvm bash_completion\n```\n\n#### 낮은 버전의 Node 설치 (여기선 14)\n```bash\nnvm install 14.17.0\n```\n\n설치가 되고, 아래와 같이 버전이 정상적으로 나오면 끝이다.\n```bash\nnode -v\nv14.17.0\n```\n\n출처 :\nhttps://caileb.tistory.com/206\n","excerpt":"원래 나는 맥북에어를 약 1년간 사용해왔는데, 인텔리제이를 돌렸더니 멈췄다. (젠장 -_-) 그래서 몇달을 고민하다 맥북프로로 넘어왔는데, node를 설치한 후에 블로그 포스팅을 하려고 npm install 명령어를 때렸더니 오류가 났다. 찾아봤더니…","fields":{"slug":"/install-node-m1/"},"frontmatter":{"date":"Jan 29, 2022","title":"MacBook Pro M1 노드 14 이하 버전 설치하기","tags":["settings"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n### 이 포스팅은 지속적으로 업데이트합니다.\n<br/>\n<br/>\n\n#### 시작 화면 설정\n* 프로그램 실행 시 프로젝트 선택 창 노출하도록\n  <br/>Settings → Appearance > System Settings → Reopen projects on startup\n\n#### 코드 스타일\n* 들여쓰기 - 탭 사용\n  <br/>Settings → Editor → Code Style → Java → Use tab character 체크, Smart tabs 체크 해제\n  \n\n\n#### Spring \n* Gradle 사용 시 \n  <br/>Build and run using, Run tests using → IntelliJ IDEA\n![](screenshot1.png)\n\n#### MyBatis\n* Mapper XML에 'No data sources are configured..' 경고가 뜰 경우\n<br/>Settings > Editor > Inspections > SQL - No data sources configured, SQL dialect detection 체크 해제\n\n#### Plugins\n* Key Promoter X\n* CodeGlance Pro\n* Rainbow Brackets\n* Quick File Preview\n\n* MyBatisX\n* JPA Buddy\n\n* Dracula Pro\n* Power mode 2\n* Pokemon Progress\n* Atom Material Icons\n* Material Theme UI\n\n","excerpt":"이 포스팅은 지속적으로 업데이트합니다. 시작 화면 설정 프로그램 실행 시 프로젝트 선택 창 노출하도록\nSettings → Appearance > System Settings → Reopen projects on startup 코드 스타일 들여쓰기 -…","fields":{"slug":"/intellij-basic-settings/"},"frontmatter":{"date":"Jan 18, 2022","title":"intellij 기본 설정","tags":["settings"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n![](screenshot.png)\n\n나는 본래 개발을 시작한 뒤로 쭈우우욱 윈도우를(..) 사용했다.\n\n그러다 이번에 들어온 회사에서 맥을 사용하게 됐고<br/>\n기본 터미널이 마음에 들지 않아 대체할 터미널을 찾던 중에 hyper를 알게 됐다.\n\n설치 방법은 [백준호님의 블로그](https://junhobaik.github.io/mac-terminal-setting/)에서 확인할 수 있으며,<br/>\n이 글에선 설정 내용이 띄엄띄엄 나오므로, 참조를 위해 나의 설정 내용을 추가한다.\n\n\nzshrc 설정\n```bash\nvi ~/.zshrc\n```\n```bash\nsource ~/.zplug/init.zsh\n\n# Plugins\nzplug \"lib/completion\",   from:oh-my-zsh\nzplug \"lib/key-bindings\", from:oh-my-zsh\nzplug \"lib/directories\",  from:oh-my-zsh\n\nzplug \"plugins/git\",      from:oh-my-zsh\nzplug \"plugins/autojump\", from:oh-my-zsh, frozen:1\n\nzplug \"zsh-users/zsh-completions\",              defer:0\nzplug \"zsh-users/zsh-autosuggestions\",          defer:1, on:\"zsh-users/zsh-completions\"\nzplug \"zsh-users/zsh-syntax-highlighting\",      defer:1, on:\"zsh-users/zsh-autosuggestions\"\nzplug \"zsh-users/zsh-history-substring-search\", defer:2, on:\"zsh-users/zsh-syntax-highlighting\"\n\nzplug \"denysdovhan/spaceship-prompt\", use:spaceship.zsh, from:github, as:theme\n\nzplug \"djui/alias-tips\"\n\n# Install plugins if there are plugins that have not been installed\nif ! zplug check --verbose; then\n    printf \"Install? [y/N]: \"\n    if read -q; then\n        echo; zplug install\n    fi\nfi\n\n# Then, source plugins and add commands to $PATH\nzplug load\n```\n\n\nhyper.js 설정\n```bash\nvi ~/.hyper.js\n```\n```javascript\n\"use strict\";\n// Future versions of Hyper may add additional config options,\n// which will not automatically be merged into this file.\n// See https://hyper.is#cfg for all currently supported options.\nmodule.exports = {\n    config: {\n        // choose either `'stable'` for receiving highly polished,\n        // or `'canary'` for less polished but more frequent updates\n        updateChannel: 'stable',\n        // default font size in pixels for all tabs\n        fontSize: 12,\n        // font family with optional fallbacks\n        fontFamily: 'Hack, Droid Sans Mono for Powerline, Menlo, \"DejaVu Sans Mono\", Consolas, \"Lucida Console\", monospace',\n        // default font weight: 'normal' or 'bold'\n        fontWeight: 'normal',\n        // font weight for bold characters: 'normal' or 'bold'\n        fontWeightBold: 'bold',\n        // line height as a relative unit\n        lineHeight: 1,\n        // letter spacing as a relative unit\n        letterSpacing: 0,\n        // terminal cursor background color and opacity (hex, rgb, hsl, hsv, hwb or cmyk)\n        cursorColor: 'rgba(248,28,229,0.8)',\n        // terminal text color under BLOCK cursor\n        cursorAccentColor: '#000',\n        // `'BEAM'` for |, `'UNDERLINE'` for _, `'BLOCK'` for █\n        cursorShape: 'BLOCK',\n        // set to `true` (without backticks and without quotes) for blinking cursor\n        cursorBlink: false,\n        // color of the text\n        foregroundColor: '#fff',\n        // terminal background color\n        // opacity is only supported on macOS\n        backgroundColor: '#000',\n        // terminal selection color\n        selectionColor: 'rgba(248,28,229,0.3)',\n        // border color (window, tabs)\n        borderColor: '#333',\n        // custom CSS to embed in the main window\n        css: '',\n        // custom CSS to embed in the terminal window\n        termCSS: '',\n        // set custom startup directory (must be an absolute path)\n        workingDirectory: '',\n        // if you're using a Linux setup which show native menus, set to false\n        // default: `true` on Linux, `true` on Windows, ignored on macOS\n        showHamburgerMenu: '',\n        // set to `false` (without backticks and without quotes) if you want to hide the minimize, maximize and close buttons\n        // additionally, set to `'left'` if you want them on the left, like in Ubuntu\n        // default: `true` (without backticks and without quotes) on Windows and Linux, ignored on macOS\n        showWindowControls: '',\n        // custom padding (CSS format, i.e.: `top right bottom left`)\n        padding: '12px 14px',\n        // the full list. if you're going to provide the full color palette,\n        // including the 6 x 6 color cubes and the grayscale map, just provide\n        // an array here instead of a color map object\n        colors: {\n            black: '#000000',\n            red: '#C51E14',\n            green: '#1DC121',\n            yellow: '#C7C329',\n            blue: '#0A2FC4',\n            magenta: '#C839C5',\n            cyan: '#20C5C6',\n            white: '#C7C7C7',\n            lightBlack: '#686868',\n            lightRed: '#FD6F6B',\n            lightGreen: '#67F86F',\n            lightYellow: '#FFFA72',\n            lightBlue: '#6A76FB',\n            lightMagenta: '#FD7CFC',\n            lightCyan: '#68FDFE',\n            lightWhite: '#FFFFFF',\n            limeGreen: '#32CD32',\n            lightCoral: '#F08080',\n        },\n        // the shell to run when spawning a new session (i.e. /usr/local/bin/fish)\n        // if left empty, your system's login shell will be used by default\n        //\n        // Windows\n        // - Make sure to use a full path if the binary name doesn't work\n        // - Remove `--login` in shellArgs\n        //\n        // Windows Subsystem for Linux (WSL) - previously Bash on Windows\n        // - Example: `C:\\\\Windows\\\\System32\\\\wsl.exe`\n        //\n        // Git-bash on Windows\n        // - Example: `C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe`\n        //\n        // PowerShell on Windows\n        // - Example: `C:\\\\WINDOWS\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe`\n        //\n        // Cygwin\n        // - Example: `C:\\\\cygwin64\\\\bin\\\\bash.exe`\n        shell: '',\n        // for setting shell arguments (i.e. for using interactive shellArgs: `['-i']`)\n        // by default `['--login']` will be used\n        shellArgs: ['--login'],\n        // for environment variables\n        env: {},\n        // Supported Options:\n        //  1. 'SOUND' -> Enables the bell as a sound\n        //  2. false: turns off the bell\n        bell: 'SOUND',\n        // An absolute file path to a sound file on the machine.\n                // bellSoundURL: '/path/to/sound/file',\n        // if `true` (without backticks and without quotes), selected text will automatically be copied to the clipboard\n        copyOnSelect: false,\n        // if `true` (without backticks and without quotes), hyper will be set as the default protocol client for SSH\n        defaultSSHApp: true,\n        // if `true` (without backticks and without quotes), on right click selected text will be copied or pasted if no\n        // selection is present (`true` by default on Windows and disables the context menu feature)\n        quickEdit: false,\n        // choose either `'vertical'`, if you want the column mode when Option key is hold during selection (Default)\n        // or `'force'`, if you want to force selection regardless of whether the terminal is in mouse events mode\n        // (inside tmux or vim with mouse mode enabled for example).\n        macOptionSelectionMode: 'vertical',\n        // Whether to use the WebGL renderer. Set it to false to use canvas-based\n        // rendering (slower, but supports transparent backgrounds)\n        webGLRenderer: true,\n        // keypress required for weblink activation: [ctrl|alt|meta|shift]\n        // todo: does not pick up config changes automatically, need to restart terminal :/\n        webLinksActivationKey: '',\n        // if `false` (without backticks and without quotes), Hyper will use ligatures provided by some fonts\n        disableLigatures: true,\n        // set to true to disable auto updates\n        disableAutoUpdates: false,\n        // set to true to enable screen reading apps (like NVDA) to read the contents of the terminal\n        screenReaderMode: false,\n        // set to true to preserve working directory when creating splits or tabs\n        preserveCWD: true,\n        // for advanced config flags please refer to https://hyper.is/#cfg\n\n        opacity : 0.999\n    },\n    // a list of plugins to fetch and install from npm\n    // format: [@org/]project[#version]\n    // examples:\n    //   `hyperpower`\n    //   `@company/project`\n    //   `project#1.0.1`\n    plugins: [\n        'hypercwd',\n        //'hyper-statusline',\n        'hyper-quit',\n        'hyper-opacity',\n        'hyper-tab-icons',\n        'hyper-materialshell',\n        'hyperborder'\n    ],\n\n    hyperBorder : {\n        borderColors : ['#e154c3', '#e154c3'],\n        borderWidth : '3px'\n    },\n\n    // in development, you can create a directory under\n    // `~/.hyper_plugins/local/` and include it here\n    // to load it and avoid it being `npm install`ed\n    localPlugins: [],\n    keymaps: {\n    // Example\n    // 'window:devtools': 'cmd+alt+o',\n    },\n};\n```\n","excerpt":"나는 본래 개발을 시작한 뒤로 쭈우우욱 윈도우를(..) 사용했다. 그러다 이번에 들어온 회사에서 맥을 사용하게 됐고\n기본 터미널이 마음에 들지 않아 대체할 터미널을 찾던 중에 hyper를 알게 됐다. 설치 방법은 백준호님의 블로그에서 확인할 수 있으…","fields":{"slug":"/hyper-terminal/"},"frontmatter":{"date":"Jan 07, 2022","title":"Hyper Terminal","tags":["settings"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n![](screenshot1.png)\n\n본 블로그를 이루고 있는 테마에 대해 소개하고자 한다.\n\n지금까지 나는 tistory, velog 등 쉽고 빠르게 접근할 수 있는 블로그 서비스들을 개인 저장소겸 블로그로 이용해왔다.\n\n그러던 중에 맥을 사용하게 돼서 하이퍼 터미널 검색 도중 백준호님의 블로그를 구경하게 됐다.\n\n블로그가 하나부터 열까지 마음에 쏙 들어서 링크를 타고 깃허브에 갔더니 테마를 쉽게 사용할 수 있도록 [문서화](https://github.com/junhobaik/junhobaik.github.io/wiki/Document-(Borderless))까지 해놓으신걸 보고, 블로그를 만들게 되었다.\n\n테마를 적용하고 싶다면 상기 링크의 문서를 참고하여 백준호님의 [github repository](https://github.com/junhobaik/junhobaik.github.io)에서 Fork/Clone 해서 적용할 수 있다.\n\n이 테마를 공유해주신 백준호님에게 감사의 말씀 드리고 싶다.\n\n<br/>\n<br/>\n\n적용하면서 documents에서 찾을 수 없었던 내용이 있는데\n\n나는 repository의 이름, _config.js를 설정하고 deploy했더니 아래와 같이 블로그가 안나오고 README가 나왔다 -.-\n\n![](screenshot2.png)\n\n혹시나 나와 같이 블로그가 안나오고 README가 나온다면 아래 설정을 확인해 봐야 한다.\n\n#### repository > settings > Pages 이동 : branch > develop를 master로 변경\n![](screenshot3.png)\n","excerpt":"본 블로그를 이루고 있는 테마에 대해 소개하고자 한다. 지금까지 나는 tistory, velog 등 쉽고 빠르게 접근할 수 있는 블로그 서비스들을 개인 저장소겸 블로그로 이용해왔다. 그러던 중에 맥을 사용하게 돼서 하이퍼 터미널 검색 도중 백준호님의…","fields":{"slug":"/introduce-blog/"},"frontmatter":{"date":"Jan 01, 2022","title":"Github Blog - Borderless Blog Theme","tags":["github"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}